[alias]

    ### Forced Pull:
    #> You have a local branch (e.g. for reviewing), but someone else did a forced push update on the remote branch. A regular git pull will fail, but this will just set the local branch to match the remote branch. BEWARE: this will overwrite any local commits you have made on this branch that haven't been pushed.
    pullf = !bash -c "git reset --hard origin/$(git rev-parse --abbrev-ref HEAD)"

    ### Pull only the current branch and dont update refs of all remotes
    pullhead = "!f() {                                                                  \
	    local b=${1:-$(git rev-parse --abbrev-ref HEAD)};                               \
	    git pull origin $b;                                                             \
    }; f"

    ### Blow up local branch and repull from remote
    smash = "!f() {                                                                     \
	    local b=${1:-$(git rev-parse --abbrev-ref HEAD)};                               \
	    echo 'Are you sure you want to run this? It will delete your current '$b'.';    \
	    read -p 'Enter to continue, ctrl-C to quit: ' response;                         \
	    git checkout master;                                                            \
	    git branch -D $b;                                                               \
	    git fetch origin $b;                                                            \
	    git checkout $b;                                                                \
    }; f"

    ### Rebase current branch off master
    rbm = "!f() {                                                                       \
	    local b=${1:-$(git rev-parse --abbrev-ref HEAD)};                               \
	    echo 'Are you sure you want to run this? It will delete your current '$b'.';    \
	    read -p 'Enter to continue, ctrl-C to quit: ' response;                         \
	    git checkout master;                                                            \
	    git pull origin master;                                                         \
	    git checkout $b;                                                                \
	    git rebase master;                                                              \
    }; f"

    ### Rebase current branch off develop
    rbd = "!f() {                                                                       \
	    local b=${1:-$(git rev-parse --abbrev-ref HEAD)};                               \
	    echo 'Are you sure you want to run this? It will delete your current '$b'.';    \
	    read -p 'Enter to continue, ctrl-C to quit: ' response;                         \
	    git checkout develop;                                                           \
	    git pull origin develop;                                                        \
	    git checkout $b;                                                                \
	    git rebase develop;                                                             \
    }; f"

    # Sort branch by date
    # Usage: git bd [-a] [-<line_limit>]
    #     -a             include remote branches and tags
    #     -<line_limit>  number of lines to tail
    # Example: git bd
    # Example: git bd -3
    # Example: git bd -a
    # Example: git bd -a -20
    # Example: git bd -a20
    bd = "!f() {                                                                            \
        case $1 in                                                                          \
            -a) refs='--'; shift;;                                                          \
            -a*) refs='--'; one=${1/-a/-}; shift; set -- $one $@;;                          \
            *) refs='refs/heads/';;                                                         \
        esac;                                                                               \
        git for-each-ref --color --count=1 1>/dev/null 2>&1 && color_flag=yes;              \
        format='--format=%(refname) %00%(committerdate:format:%s)%(taggerdate:format:%s) %(color:red)%(committerdate:relative)%(taggerdate:relative)%(color:reset)%09%00%(color:yellow)%(refname:short)%(color:reset) %00%(subject)%00 %(color:reset)%(color:dim cyan)<%(color:reset)%(color:cyan)%(authorname)%(taggername)%(color:reset)%(color:dim cyan)>%(color:reset)'; \
        {                                                                                   \
            {                                                                               \
                [ '$color_flag' = yes ] && git for-each-ref --color $format $refs || git -c color.ui=always for-each-ref $format $refs; \
            } |                                                                             \
                grep -v '^refs/stash/';                                                     \
            [ '$refs' = '--' ] && git show-ref -q --verify refs/stash && git log --color --walk-reflogs --format='%gd %x00%ct %C(red)%cr%C(reset)%x09%x00%C(yellow)%gd%C(reset) %x00%s%x00 %C(reset)%C(dim cyan)<%C(reset)%C(cyan)%an%C(reset)%C(dim cyan)>%C(reset)' refs/stash; \
        } |                                                                                 \
            awk '{sub(/^refs\\/tags\\/[^x00]*x00([^x00]*)x00([^x00]*)/, \"\\1(tag) \\2\"); sub(/^[^x00]*x00([^x00]*)x00/, \"\\1\"); sub(/x00([^x00]{0,50})([^x00]*)x00/, \"\\1\\033[1;30m\\2\\033[0m\"); print}' | \
            sort -n -k1,1 |                                                                 \
            cut -d' ' -f2- |                                                                \
            tail ${@:--n+0};                                                                \
    }; f"

    l = "!f() {  \
        commit_count='$(git rev-list --count HEAD@{upstream}..HEAD 2>/dev/null || echo 2)'; \
        commit_count=$(( commit_count + 3 ))                                                \
        [ '$commit_count' -lt 5 ] && commit_count=5;                                        \
        [ '$commit_count' -gt 20 ] && commit_count=20;                                      \
        git --no-pager log                                                                  \
            --format='%C(auto)%h %C(reset)%C(dim red)[%C(reset)%C(red)%cr%C(reset)%C(dim red)]%C(reset)%C(auto) %x02%s%x03 %C(reset)%C(dim cyan)<%C(reset)%C(cyan)%an%C(reset)%C(dim cyan)>%C(reset)%C(auto)%d%C(reset)' \
            --color --graph '-$commit_count' '$@' |                                         \
            sed -r 's/([0-9]+) (seconds|minutes|hours|days|weeks) ago/\\1\\2/' |            \
            less -RFX;                                                                      \
    }; f"

    fetch-pr = "!f() { \
        git remote get-url $1 >/dev/null 2>&1 || { printf >&2 'Usage: git fetch-pr <remote> [<pr-number>]\n'; exit 1; }; \
        pr=$2; \
        [ -z $pr ] && pr='*'; \
        git fetch $1 '+refs/pull/$pr/head:refs/remotes/$1/pr/$pr';\
    }; f"

    stash-staged = "!f() { : git stash ;                                                                                  \
    staged=$(git diff --staged --unified=0);                                                                              \
    unstaged=$(git diff --unified=0);                                                                                     \
    [ '$staged' = '' ] && return;                                                                 \
    [ '$unstaged' = '' ] && { git stash $@; return $?; };                                                                                         \
    printf 'This is a potentially destructive command.\nBe sure you understand it before running it.\nContinue? [y/N]: ';   \
    IFS= read -r cont; echo $cont | grep -iq '^y' || { echo 'Not continuing.'; return 1; };                               \
    git reset --hard && echo -E $staged |                                                                               \
        git apply --unidiff-zero --allow-empty - &&                                                                                       \
        git stash $@ &&                                                                                                   \
        echo -E $unstaged | git apply --unidiff-zero --allow-empty - || {                                                                 \
            top=$(git rev-parse --git-dir);                                                                               \
            echo -E $staged >$top/LAST_STAGED.diff;                                                                     \
            echo -E $unstaged >$top/LAST_UNSTAGED.diff;                                                                 \
            printf 'ERROR: Could not stash staged.\nDiffs saved: try git apply --unidiff-zero .git/LAST_STAGED.diff .git/LAST_UNSTAGED.diff\n'; \
        };                                                                                                                  \
    }; f"

    stash-unstaged = "!f() { : git stash ;                                                                                  \
    staged=$(git diff --staged --unified=0);                                                                              \
    unstaged=$(git diff --unified=0);                                                                                     \
    [ '$staged' = '' ] && { git stash $@; return $?; };                                                                 \
    [ '$unstaged' = '' ] && return;                                                                                         \
    printf 'This is a potentially destructive command.\nBe sure you understand it before running it.\nContinue? [y/N]: ';   \
    IFS= read -r cont; echo $cont | grep -iq '^y' || { echo 'Not continuing.'; return 1; };                               \
    git reset --hard && echo -E $unstaged |                                                                               \
        git apply --unidiff-zero - &&                                                                                       \
        git stash $@ &&                                                                                                   \
        echo -E $staged | git apply --unidiff-zero --allow-empty - || {                                                                 \
            top=$(git rev-parse --git-dir);                                                                               \
            echo -E $staged >$top/LAST_STAGED.diff;                                                                     \
            echo -E $unstaged >$top/LAST_UNSTAGED.diff;                                                                 \
            printf 'ERROR: Could not stash unstaged.\nDiffs saved: try git apply --unidiff-zero .git/LAST_STAGED.diff .git/LAST_UNSTAGED.diff\n'; \
        };                                                                                                                  \
    }; f"
